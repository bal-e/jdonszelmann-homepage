---
layout: "../../layouts/Blog.astro"
title: 'Global Registration'
pubDate: 2024-07-10
authors: ['jdonszelmann']
reviewers: []
tags: [ "rust"]
description: |
    Writing unit tests in Rust is super easy because the compiler does a lot of heavy lifting for us.
    You can slap `#[test]` on a function anywhere in your crate and it will automatically be run for you.
    Collecting items from across a crate is introspective functionality that users can't really implement themselves.
    Crates like Criterion, Dioxus, and Bevy could benefit from this functionality but they need help from the compiler.
draft: true
---
import User from '../../components/GithubUser.astro';

[Criterion](https://docs.rs/criterion) is a custom benchmarking framework which provides great statistical analyses of performance.
If you've ever used it before, you may have seen this pattern:

```rust
fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("benchmark_1", benchmark_1);
    c.bench_function("benchmark_2", benchmark_2);
    c.bench_function("benchmark_3", benchmark_3);
    // ...
    c.bench_function("benchmark_n", benchmark_n);
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

Every benchmarking function has to be explicitly registered with the Criterion runtime, because Criterion has no way of automatically discovering those functions.
Being explicit has upsides, but it would be really convenient if we could write:

```rust
#[bench]
fn benchmark_1(b: &mut Bencher) {}

#[bench]
fn benchmark_2(b: &mut Bencher) {}

#[bench]
fn benchmark_3(b: &mut Bencher) {}

// ...

#[bench]
fn benchmark_n(b: &mut Bencher) {}

// Find all functions marked with `#[bench]` automatically.
criterion_main!();
```

I call this pattern _global registration:_ collecting marked items across a crate, or even across all the crates in an executable.
We see it in many places:
registering routes for a webserver;
[defining logging filters for the `tracing` crate](https://github.com/rust-lang/testing-devex-team/issues/3#issuecomment-2112822128);
[type reflection](https://github.com/bevyengine/bevy/issues/3936);
even for defining commmand-line flags.
Personally, I needed this functionality for implementing unit tests in embedded code.
Rust's testing infrastructure relies on compiler magic to do this work, but none of these use cases can benefit.

A lot of people want such a feature to exist.
For relevant libraries, such a feature can vastly improve the user-facing API.
At [RustNL 2024](https://2024.rustnl.org), I talked to <User name="epage" /> who wants this for the [Testing Devex team](https://github.com/rust-lang/testing-devex-team), so that custom testing frameworks work as effectively as Rust's default.
Since that conversation, I've been thinking about this feature.
I wrote a [Pre-RFC](https://internals.rust-lang.org/t/global-registration-a-kind-of-pre-rfc/20813/26) and received a lot of community feedback.
I've worked on implementing this feature in the compiler, and now it's mostly complete.
I'm just not 100% sure that that's the implementation we want anymore.

Why? Well, that's what the rest of this blog post is about.

# Existing Solutions

While direct support from the compiler is the ideal way to implement this feature, as always, people have come up with interesting workarounds.
I want to take a moment to talk about the three most prominent ones.
The first is a compiler feature, while the latter two are libraries mantained by <User name="dtolnay" />.

## Custom Test Frameworks

The Rust community has demanded support for custom test frameworks for a while, and it has always been clear that the compiler's test collection functionality would have to be extended to support them.
There's already an implementation of this floating around, through the [unstable `custom_test_frameworks` feature](https://doc.rust-lang.org/nightly/unstable-book/language-features/custom-test-frameworks.html).
Unfortunately, this is only targeted to the use case of custom test frameworks, and in its current form, it will likely never be stable.

For a course I teach, students have to write embedded Rust code to program a drone.
I've recommended `custom_test_frameworks` to them before, but they didn't tend to use it.
// TODO: Explain why students didn't like using this feature.

// TODO: Expand a bit more on the design of this feature.

## Inventory

[Inventory](https://docs.rs/inventory/latest/inventory/) collects items using *global constructors*.
This is an arcane mechanism provided by many C/C++ compilers: it allows users to register code to be run before `main()`.
The underlying implementation differs between platforms, but it usually involves some kind of linker magic.
C++ uses these to run constructors for global variables, and in Rust you can use them through [ctor](https://docs.rs/ctor).
If you would like to know more, I rather liked [this explainer](https://maskray.me/blog/2021-11-07-init-ctors-init-array).

For every item marked by the user, Inventory defines a new global constructor, which will (atomically) add the item to a global linked list.
Items of a different type are put in a different linked list, so that different kinds of information can be collected.
Here's an example, adopted from their documentation:

```rust
pub struct Flag {
    short: char, name: &'static str,
}

inventory::submit! {
    Flag::new('v', "verbose")
}
// ====== generates rougly ========
// linked list node
static NODE: ... = Node::new(/* the flag */);
// runs when the program starts before main
#[cfg(link_section = ".text.startup")]
unsafe extern "C" fn __ctor() {
    // where T: Collect
    unsafe { add_to_registry::<T>(NODE); }
}
// ================================

inventory::collect!(Flag);
// ====== generates rougly ========
impl Collect for Flag {
    fn registry() -> Registry {
        // A registry is a linked list
        // this is what the add_to_registry function adds to 
        static REGISTRY: ... = Registry::new();
        &REGISTRY
    }
}
// ================================

fn main() {
    // iterate through the linked list 
    // which was built just before main started
    for flag in inventory::iter::<Flag> {
        println!("-{}, --{}", flag.short, flag.name);
    }
}
```

Inventory works quite well, and even works from dynamic libraries.
However, not all platforms support running code before `main()`; most notably, embedded platforms don't really work.

> Using global constructors in Rust code is quite tricky.
> The standard library does a lot of work before `main()`,
> such as preparing the threading infrastructure,
> configuring standard input and output,
> and collecting the command-line arguments.
> There are no guarantees that this will be available to global constructors.
> Thus, Inventory does the bare minimum within its constructor functions.

## Linkme

An alternative to Inventory is [`linkme`](https://docs.rs/linkme/latest/linkme/).
Instead of relying on global constructors, `linkme` uses linker magic.
Object files contain different kinds of data (code, global variables, etc.), organized into _sections_.
When a linker processes object files, it collects the data for each section together.
Using arcane linker features, `linkme` defines its own sections and puts marked items in them.
The linker will collect items from statically and dynamically linked crates together automatically.
At runtime, it provides access to collections of items by traversing the contents of the corresponding section.
Again, adapting the example from the docs:

```rust
use linkme::distributed_slice;

// all the elements ultimately "appear" here
#[distributed_slice]
pub static BENCHMARKS: [fn(&mut Bencher)];

// adds to the static above
// by placing this in a specific linker section
#[distributed_slice(BENCHMARKS)]
static BENCH_DESERIALIZE: fn(&mut Bencher) = bench_deserialize;
fn bench_deserialize(b: &mut Bencher) {}

// tries to generate a linker section that contains:
// __SPECIAL_START_SYMBOL
// &BENCH_DESERIALIZE
// ... more elements
// __SPECIAL_END_SYMBOL
```

Now, `BENCHMARKS` will point to the elements between the special start and end symbols.
No code needs to be run before `main()`, so `linkme` is portable to more platforms.
However, it doesn't support dynamic library loading.

At this point, an obvious reaction is:

# Why don't we put this in the compiler?

If the compiler could generate this kind of distributed slice, the issue of platform support disappears.
This is basically how `libtest` works.
So, after [talking about it on internals.rust-lang.org](https://internals.rust-lang.org/t/global-registration-a-kind-of-pre-rfc/20813) 
I enthusiastically added what is essentially `linkme` to the compiler.
The implementation even considers the possibility of some day supporting dynamic linking if Rust ever starts properly doing that.

> Note, in past discussions this feature was often called "distributed slice". 
> That's also the name of the version from the `linkme` crate.
> I renamed it because it being specifically a slice exposes too much of the internal working of the feature,
> and it removes a lot of flexibility to change the design later.

```rust
#![feature(global_registration)]

use core::global_registration::{global_registry, register, Registry};

#[global_registry]
static ERROR_MSGS: Registry<&str>;

register!(ERROR_MSGS, "a");
register!(ERROR_MSGS, "b");

fn main() {
    for msg in ERROR_MSGS {
        println!("{}", msg);
    }
}
```

One crate defines a registry, with `#[global_registry]`; 
anyone can add to it and in the final binary a static appears that, when iterated over, contains all the elements. Neat!

Of course, I acted first and only then thought about it properly...
After lots of incredibly helpful discussion with <User name="m-ou-se"/>, 
we realised that this has a lot of implications.
Let's do some thought experiments, and discuss what they mean.

## Visibility

> If a registry is public, should anyone be able to add to it? 
> Does `pub` mean read or write access?
> On a related note, does `pub use` forward this read and/or write access?

An option that we considered is somehow applying two visibilities to a registry definition, or splitting it up in two parts:

```rust
#[global_registry(pub REGISTRY_ADDER)]
static ERROR_MSGS: Registry<&str>;

// in another crate:

// the adder is public so this is ok
register!(REGISTRY_ADDER, "b");
```

I think the only design that makes sense is that `pub` forwards both read and write access,
if you want a read-only registry you can make it not public but provide a public getter function that returns the elements:
```rust
// private
#[global_registry]
static ERROR_MSGS: Registry<&str>;

// public getter
pub fn get_error_msgs() -> &Registry<&str> {
    &ERROR_MSGS
}
```
If you somehow want a write-only registry, you're out of luck.

## Versioning

> What happens if there are two *different* versions of a crate that defines a global registry in the dependency tree.

Imagine a crate graph like this:

```bash
cargo tree
a v0.1.0
├── b v0.1.0
│   └── c v0.1.0
└── c v0.2.0
```

`c` defines a global registry `ERROR_MSGS`. 
`b` adds some messages, and `a` reads them, 
getting access to the registy by importing a *different version* of `c`.
The only possibility is that `a` does not see the items added by `b`.

You can already encounter this problem with the `log` crate right now.
They did employ the [semver trick](https://github.com/dtolnay/semver-trick) to make it somewhat complicated to construct.

## Compile time access

> If the compiler implements this feature, why is the information only available at runtime?
> What stops us from collecting registered elements to a `const` like this?
```rust
// private
#[global_registry]
const ERROR_MSGS: Registry<&str>;

register!(ERROR_MSGS, "a");
register!(ERROR_MSGS, "b");
```

It would be rather convenient if you could for example sort the elements at compile time 
(ignoring problems with us not yet having traits in const fns).
In fact, it seems rather likely that most uses of global registries will be hidden in macros. 
Like a `#[test]` attribute, or `#[get("/")]` on a server route.
So why couldn't registries be a part of the macro machinery?

The answer to all this is quite simple, 
we can only know all the items in a registry once all crates in a dependency tree are compiled.
At that point we can't go back and rerun const fns in other crates with the final list of items, 
and we definitely can't expand any macros in dependent crates anymore.

## Registration in dependencies

> Let's think of a usecase. A custom testing framework. 
> The framework defines a registry of tests, and in your crate you add to it.
> Some dependency of yours uses the same version of the same test framework. 
> When you run your tests, should the tests of the dependency also run?

If the registry is truely global, that's exactly what'd happen, but it's not at all how tests behave right now.
Obviously, each crate should get its own crate-local registry of tests.
In fact, I'm not sure there's ever a usecase where you genuinely want global registration.
A benchmarking framework will also be crate-local, and the routes for a webserver probably as well.
It can even be pretty confusing if some far far dependency accidentally (or even maliciously) injects some extra routes in your webserver.

So why did I initially implement inter-crate global registration?
I thought that was the thing people wanted.
For a little while I was afraid I'd misunderstood what people thought this feature meant, 
or implemented the wrong thing.
But this is the design I sketched in my [pre-rfc](https://internals.rust-lang.org/t/global-registration-a-kind-of-pre-rfc/20813), where everyone generally agreed with it.
Maybe that's because of the way I framed it.
However, it's also just the version of global registration people are used to. 
That's what linkme and inventory provide.

In any case, I now believe that *actually global* registration is not something we should want.

# An alternative design

A fact is that [testing devex wants to make custom test frameworks a thing](https://github.com/rust-lang/testing-devex-team/issues/2), 
and I think it's safe to conclude that this same pattern is useful in other places too.
Let's start from the beginning.

To support custom test frameworks, we at least want a way to register items from various modules within a single crate.
So lets start with single-crate registries. 
That also resolves some problems with registry visibility, 
within a single crate it's less important who's allowed to add to a registry since you control all the code.
In fact, now a registry could actually be a const and available during const evaluation, 
since within a crate that shouldn't really be an issue. Neat!

At this point we can also drop any issues related to registries and dynamic linking.
Everything happens before and during const evaluation and dynamic linking isn't yet relevant.

## Intercrate sometimes?

It's not true that there are *no* applications for inter-crate registries.
Talking to some friends, we came up with some examples

* A dependency might define some routes that you can just import.
* <User name="epage" /> talked about wanting a dependency to register test fixtures.
* Sometimes in embedded programming, the only actually runable crate is your main crate (it contains the code to boot the processor).
  However, this main crate might then actually want to run test from dependencies as they wouldn't be able to boot on their own.
* A dependency of yours defines some metrics, you want to register those, and some more of your own.
  You might also want to combine several lists of metrics from several dependencies.

Still, you want to limit the number of crates these items can come from. 
You don't want a random dependency's metrics, or server routes, or tests.
A way to solve this, is to explicitly register them.

```rust
use other_crate::OTHER_ROUTES;

#[global_registry]
const MY_ROUTES: &[Route];

register_many!(MY_ROUTES, OTHER_ROUTES);
```

I think having this is pretty neat, as you can now register any const slice of elements.

# Unsolved questions

I think that designing registries like this solves most of the 
complicated questions associated with the magic intercrate global registration that I implemented.
Adding elements from different crates is possible, but much more explicit now.
However, there are also some things I haven't completely worked out yet.

In truth, that's why I began writing this blogpost. 
This is roughly where I got to, and maybe someone else has a brilliant idea.

## Stable identifier

I think it will be common to hide global registries in macros.
From a user's perspective, it looks like tests are somewhat magically collected, and I actually think that's alright.
So let's look at an example of what a custom test framework could look like:

```rust
use custom_test_framework::test_main;

fn main() {
    #[cfg(test)]
    test_main!()
}

#[cfg(test)]
mod tests {
    use custom_test_framework::custom_test;

    #[custom_test]
    fn test_a() {}

    #[custom_test]
    fn test_b() {}
}
```

I think this looks pretty neat, if this worked.
Using [`#![feature(custom_test_frameworks)]`](https://doc.rust-lang.org/nightly/unstable-book/language-features/custom-test-frameworks.html) I've written
tests for embedded systems that look pretty much exactly like this.
But where, in this example is the global registry defined?
If `test_main!` defines it, with some name, how does `#[custom_test]` refer to it?
`test_main!` is invoked in a function scope.
Maybe you'd have a 3rd macro, that you'd have to put above main to define the registry.

```rust
use custom_test_framework::{test_main, init};

init!()

fn main() {
    #[cfg(test)]
    test_main!()
}

#[cfg(test)]
mod tests {
    use custom_test_framework::custom_test;

    #[custom_test]
    fn test_a() {}

    #[custom_test]
    fn test_b() {}
}
```

Actually, nowhere here we use the name of the global registry.
That's actually fine hygiene-wise because top level items don't really have hygiene in Rust,
but it'd probably give some weird errors when you call `init!` twice, or not at all.
It's all a little unfortunate.

## NonLocal DefIDs

Under this crate-local version of global registration, 
an implementation would probably look like a hashmap that maps from the `DefId` of the registry definition to a list of all the elements.
This `DefId` key could in theory be any `DefId`. 
Also one that lives outside the current crate.
In theory, this could be valid:

```rust
register!(custom_test_framework, some_test);
```

The identifier `custom_test_framework`, the name of our custom test framework crate is easy to refer to from anywhere in the program.
Alternatively you could refer to some identifier *in* `custom_test_framework`.
I think this is incredibly complicated to teach the community.
Also, it can be confusing because if you bind a registry to an identifier in a different crate, 
that crate itself won't get access to the elements as registration will be crate-local.

## Compile time collections

At this point, we're inventing a lot of new features that together gives users what's essentially a compile-time growable vector.
You can add single `const` elements, concat `const` slices from different crates into one larger slice, and iterate over them.
However, that's a completely new thing to Rust. 
Rust doesn't really have a compile-time only collection type, nor the ability to express that.
Maybe that's an abstraction that we'd need first in Rust before implementing this feature, 
because right now there's a lot of compiler magic going on that's likely hard to teach to users of the language.

# Externally Implementable Items

Many of the things I've written about here come from discussions with <User name="m-ou-se" />, 
as we thought that a feature she was working on ([Externally Implementable Items; EII](https://github.com/rust-lang/rust/issues/125418)) 
would have a very similar implementation to global registration.

Basically, externally implementable items are like registering a single element in a global registry.
Or worded differently, a global registry is like having the possibility to provide more than one externally implemented element.

In the end I think we worked out a rather neat design for EII (more info probably coming soon), 
but one that does not help implement global registration.

# Conclusion

Well, that's where global registration stands now.
I'm pretty sure we should not want the kind of inter-crate that I originally implemented.
A more explicit importing of elements from other crates leads to fewer surprises.
However, as you can see there are still some details that I'm not entirely sure about how to solve.
Let me know if you have any ideas!


